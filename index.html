<!DOCTYPE html>
<html>

<head>
    <meta charset=urf-8/>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=yes' />
    <title>San Francisco Car Break-ins Crime Map</title>
    <link rel='stylesheet' href='http://libs.cartocdn.com/cartodb.js/v3/3.11/themes/css/cartodb.css' />
    <script src='http://libs.cartocdn.com/cartodb.js/v3/3.11/cartodb.js'></script>
    <script type="text/javascript" src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script>
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>
</head>
<style>
body {
    margin: 0;
    padding: 0;
    font-family: 'Roboto', 'Helvetica', sans-serif;
   /* font-family: "Garamond", serif;*/
    font-weight: 300;
}

#map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
}

#control {
    position: absolute;
    top: 5px;
    right: 10px;
    color: white;
    font-family: Georgia;
    font-size: small;
    padding-left: 20px;
    padding-right: 20px;
    background-color: rgba(0, 0, 0, 0.5);
}

#bkcard {
    background-color: rgba(0, 0, 0, .8);
    /*border-radius: 5px;*/
    position: absolute;
    right: 0px;
    width: 350px;
    height: 100%;
    z-index: 0;
    color: white;
    overflow-y: scroll;
}

#bkcard h2 {
    color: white;
    padding-left: 20px;
    margin-bottom: 0px;
    font-size: 23px
}

#bkcard h3 {
    color: white;
    padding-left: 20px;
}

#bkcard p {
    color: white;
    font-size: 12px;
    padding-left: 20px;
    padding-top: 0px;
    font-size: 14px;
}

#bkcard #credit{
    font-size: 12px;
}

div.cartodb-searchbox {
    position: absolute;
    top: 90px;
    left: 20px;
    z-index: 99 !important;
}

#menu {
    background: transparent;
    z-index: 10;
    padding-left: 20px;
}

#menu a {
    margin: 15px 10px 0 0;
    float: left;
    vertical-align: baseline;
    width: 125px;
    padding: 10px;
    text-align: center;
    font: bold 8px "Helvetica", Arial;
    line-height: normal;
    color: #555;
    border-radius: 4px;
    border: 1px solid #777777;
    background: #ffffff;
    text-decoration: none;
    cursor: pointer;
}

#menu a.selected,
#menu a:hover {
    color: steelblue;
}

path.leaflet-clickable {
    fill: black;
    stroke: black;
    opacity: 1;
}

#map {
    z-index: -1;
}

#power-gauge1 {
    padding-left: 20px;
    margin-top: 50px;
}

#power-gauge2 {
    padding-left: 20px;
   
}

#power-gauge1 g.pointer {
    fill: white;
    stroke: lightgrey;
}

#power-gauge2 g.pointer {
    fill: white;
    stroke: lightgrey;
}

#power-gauge1 g.label text {
    text-anchor: middle;
    font-size: 10px;
    font-weight: bold;
    fill: white;
}

#power-gauge2 g.label text {
    text-anchor: middle;
    font-size: 10px;
    font-weight: bold;
    fill: white;
}
</style>
<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<body>
    <div id='map'></div>
    <div id="bkcard">
        <h2>San Francisco Car Break-ins</h2>
        <p id="credit">By Jieqian Zhang</p>
        <p>Live crime data of the past year from San Francisco Police Department (updated daily)</p>
        <div id='menu' onclick="detectUserLocation()">
            <a id="detect">FIND BREAK-INS AROUND YOU</a>
        </div>
        <div id="power-gauge1"></div>
        <div id="power-gauge2"></div>
        <h3>Methdology</h3>
    </div>
    <script>
    var map = new L.map('map').setView([37.77, -122.41], 12);
    // L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
    L.tileLayer('http://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);


    var sublayer;

    cartodb.createLayer(map, {
            user_name: "jqzhang",
            type: 'cartodb',
            sublayers: [{
                sql: "WITH crimes AS (SELECT * FROM (SELECT *, to_date(date, 'MM/DD/YYYY') AS incdate FROM yvry) AS crimes WHERE incdate >= now() - interval '1 year') SELECT neighborhoods_areas.the_geom_webmercator,neighborhoods_areas.neighborho, count(crimes.the_geom_webmercator) *10000 /neighborhoods_areas.area AS rate FROM neighborhoods_areas, crimes WHERE ST_Contains(neighborhoods_areas.the_geom_webmercator, crimes.the_geom_webmercator) GROUP BY neighborhoods_areas.the_geom_webmercator, neighborhoods_areas.neighborho, neighborhoods_areas.area",
                cartocss: "#yvry{polygon-fill: #FFFFB2; polygon-opacity: 0.8;line-color: #FFF;line-width: 0.5;line-opacity: 1;}#yvry[rate<=13.4502033352671]{polygon-fill: #c51b7d;}#yvry[rate<=7.96100602097922]{polygon-fill: #e9a3c9;}#yvry[rate<=2.24165005995164]{polygon-fill: #fde0ef;}#yvry[rate<=1.48236717330872]{polygon-fill: #f7f7f7;}#yvry[rate<=0.734503065922202]{polygon-fill: #e6f5d0;}#yvry[rate<=0.620246533008774]{polygon-fill: #a1d76a;}#yvry[rate<=0.447005419095189]{polygon-fill: #4d9221;}",
            }]
        })
        .addTo(map)
        .done(function(layer) {
            // var v = cdb.vis.Overlay.create('search', map.viz, {})
            // v.show();
            // $('#bkcard').append(v.render().el);
            // sublayer = layer.getSubLayer(0);

        }).on('error', function() {
            //log the error
        });

    // calculate the crime rate per m2 in the entire city 

    
    var city_crime_rate;

    var sql = new cartodb.SQL({
            user: 'jqzhang',
            format: 'json'
        })


        sql.execute("SELECT (SELECT COUNT(cartodb_id) FROM (SELECT * FROM (SELECT *, to_date(date, 'MM/DD/YYYY') AS incdate FROM yvry) AS crimes WHERE incdate >= now() - interval '1 year') AS year_crime) * 10000 /(SELECT SUM(area) FROM neighborhoods_areas) AS city_crime_rate")
            .done(function(data) {

                city_crime_rate = data.rows[0].city_crime_rate;

            });

    



    var loc_crime_rate;


    // get geolocation from the web-browser
    function mapToPosition(position) {
        var lon = position.coords.longitude;
        var lat = position.coords.latitude;
        // updateQuery();
        map.setView(new L.LatLng(lat, lon), 15);
        new L.CircleMarker([lat, lon], {
            radius: 5
        }).addTo(map);


        // create a buffer
        cartodb.createLayer(map, {
                user_name: "jqzhang",
                type: 'cartodb',
                sublayers: [{
                    sql: "SELECT ST_Transform(ST_Buffer(CDB_LatLng(" + lat + "," + lon + ")::geography,1000)::geometry, 3857) AS the_geom_webmercator, 1 AS cartodb_id",
                    cartocss: '#yvry{polygon-fill: darkgrey; polygon-opacity: 0.5;line-color: darkgrey;line-width: 0.5; line-opacity: 1;}',
                }]
            })
            .addTo(map, 0);

        


        // calculate the crime rate within 1 km radius of the user

        var sql = new cartodb.SQL({
            user: 'jqzhang',
            format: 'json'
        })


        sql.execute("WITH crimes AS (SELECT * FROM (SELECT *, to_date(date, 'MM/DD/YYYY') AS incdate FROM yvry) AS crimes WHERE incdate >= now() - interval '1 year'), buffer AS (SELECT ST_Buffer(CDB_LatLng(" + lat + "," + lon + ")::geography,100)::geometry AS the_geom) SELECT COUNT(cartodb_id) * 10000 /(SELECT ST_AREA(buffer.the_geom::geography) FROM buffer) AS loc_crime_rate FROM crimes, buffer WHERE ST_Intersects(crimes.the_geom, buffer.the_geom)")
            .done(function(data) {

                loc_crime_rate = data.rows[0].loc_crime_rate;

                console.log(loc_crime_rate);


            });

    };



    // cartodb.createLayer(map, {
    //         user_name: "jqzhang",
    //         type: 'cartodb',
    //         sublayers: [{
    //             sql: "WITH crimes AS (SELECT * FROM (SELECT *, to_date(date, 'MM/DD/YYYY') AS incdate FROM yvry) AS crimes WHERE incdate >= now() - interval '1 year'), buffer AS (SELECT ST_Buffer(CDB_LatLng(" + lat + "," + lon + ")::geography,1000)::geometry AS the_geom) SELECT buffer.the_geom AS the_geom_webmercator, ST_Transform(buffer.the_geom, 3857) AS the_geom_webmercator, COUNT(cartodb_id)/(SELECT ST_AREA(buffer.the_geom::geography) FROM buffer) AS loc_crime_rate, 1 as cartodb_id FROM crimes, buffer WHERE ST_Intersects(crimes.the_geom, buffer.the_geom) GROUP BY buffer.the_geom",
    //             cartocss: '#yvry{polygon-fill: orange; polygon-opacity: 0.5;line-color: darkgrey;line-width: 0.5; line-opacity: 1;}',
    //         }]
    //     })
    //     .addTo(map, 0);
    // };


    function detectUserLocation() {
        if (navigator.geolocation) {
            var timeoutVal = 10 * 1000 * 1000;
            navigator.geolocation.watchPosition(
                mapToPosition

                // alertError, {
                //     enableHighAccuracy: true,
                //     timeout: timeoutVal,
                //     maximumAge: 0
                // }
            );
        } else {
            alert("Geolocation is not supported by this browser");
        }

        //     function alertError(error) {
        //         var errors = {
        //             // 1: 'Permission denied',
        //             // 2: 'Position unavailable',
        //             // 3: 'Request timeout'
        //         };
        //         alert("Error: " + errors[error.code]);
        //     }
    };
    </script>







    <!--  *******************************************************************************************************draw two half gauges**************************************************************************************** -->
    <script>
    var gauge = function(container, configuration) {
        var that = {};
        var config = {
            size: 200,
            clipWidth: 200,
            clipHeight: 110,
            ringInset: 15,
            ringWidth: 20,

            pointerWidth: 10,
            pointerTailLength: 7,
            pointerHeadLengthPercent: 0.9,

            minValue: 0,
            maxValue: 100,

            minAngle: -90,
            maxAngle: 90,

            transitionMs: 750,

            majorTicks: 7,
            labelFormat: d3.format(',g'),
            labelInset: 10,

            arcColorFn: ["#4d9221", "#a1d76a", "#e6f5d0", "#f7f7f7", "#fde0ef", "#e9a3c9", "#c51b7d"]
        };
        var range = undefined;
        var r = undefined;
        var pointerHeadLength = undefined;
        var value = 0;

        var svg = undefined;
        var arc = undefined;
        var scale = undefined;
        var ticks = undefined;
        var tickData = undefined;
        var pointer = undefined;

        var donut = d3.layout.pie();

        function deg2rad(deg) {
            return deg * Math.PI / 180;
        }

        function newAngle(d) {
            var ratio = scale(d);
            var newAngle = config.minAngle + (ratio * range);
            return newAngle;
        }

        function configure(configuration) {
            var prop = undefined;
            for (prop in configuration) {
                config[prop] = configuration[prop];
            }

            range = config.maxAngle - config.minAngle;
            r = config.size / 2;
            pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);

            // a linear scale that maps domain values to a percent from 0..1
            scale = d3.scale.linear()
                .range([0, 1])
                .domain([config.minValue, config.maxValue]);

            ticks = scale.ticks(config.majorTicks);
            tickData = d3.range(config.majorTicks).map(function() {
                return 1 / config.majorTicks;
            });

            arc = d3.svg.arc()
                .innerRadius(r - config.ringWidth - config.ringInset)
                .outerRadius(r - config.ringInset)
                .startAngle(function(d, i) {
                    var ratio = d * i;
                    return deg2rad(config.minAngle + (ratio * range));
                })
                .endAngle(function(d, i) {
                    var ratio = d * (i + 1);
                    return deg2rad(config.minAngle + (ratio * range));
                });
        }
        that.configure = configure;

        function centerTranslation() {
            return 'translate(' + r + ',' + r + ')';
        }

        function isRendered() {
            return (svg !== undefined);
        }
        that.isRendered = isRendered;

        function render(newValue) {
            svg = d3.select(container)
                .append('svg:svg')
                .attr('class', 'gauge')
                .attr('width', config.clipWidth)
                .attr('height', config.clipHeight);

            var centerTx = centerTranslation();

            var arcs = svg.append('g')
                .attr('class', 'arc')
                .attr('transform', centerTx);

            arcs.selectAll('path')
                .data(tickData)
                .enter().append('path')
                .attr('fill', function(d, i) {
                    return config.arcColorFn[i];
                })
                .attr('d', arc);

            var lg = svg.append('g')
                .attr('class', 'label')
                .attr('transform', centerTx);
            lg.selectAll('text')
                .data(ticks)
                .enter().append('text')
                .attr('transform', function(d) {
                    var ratio = scale(d);
                    var newAngle = config.minAngle + (ratio * range);
                    return 'rotate(' + newAngle + ') translate(0,' + (config.labelInset - r) + ')';
                })
                .text(config.labelFormat);

            var lineData = [
                [config.pointerWidth / 2, 0],
                [0, -pointerHeadLength],
                [-(config.pointerWidth / 2), 0],
                [0, config.pointerTailLength],
                [config.pointerWidth / 2, 0]
            ];
            var pointerLine = d3.svg.line().interpolate('monotone');
            var pg = svg.append('g').data([lineData])
                .attr('class', 'pointer')
                .attr('transform', centerTx);

            pointer = pg.append('path')
                .attr('d', pointerLine /*function(d) { return pointerLine(d) +'Z';}*/ )
                .attr('transform', 'rotate(' + config.minAngle + ')');

            update(newValue === undefined ? 0 : newValue);
        }
        that.render = render;

        function update(newValue, newConfiguration) {
            if (newConfiguration !== undefined) {
                configure(newConfiguration);
            }
            var ratio = scale(newValue);
            var newAngle = config.minAngle + (ratio * range);
            pointer.transition()
                .duration(config.transitionMs)
                .ease('elastic')
                .attr('transform', 'rotate(' + newAngle + ')');
        }
        that.update = update;

        configure(configuration);

        return that;
    };
    </script>
    <script>
    function onDocumentReady() {
        var powerGauge1 = gauge('#power-gauge1', {
            size: 180,
            clipWidth: 200,
            clipHeight: 120,
            ringWidth: 30,
            maxValue: 100,
            transitionMs: 4000,
        });
        powerGauge1.render();

        var powerGauge2 = gauge('#power-gauge2', {
            size: 180,
            clipWidth: 200,
            clipHeight: 120,
            ringWidth: 30,
            maxValue: 100,
            transitionMs: 4000,
        });
        powerGauge2.render();

        function updateReadings() {
            // just pump in random data here...
            powerGauge1.update(Math.random() * 100);
            powerGauge2.update(Math.random() * 100);
        }

        // every few seconds update reading values
        updateReadings();
        setInterval(function() {
            updateReadings();
        }, 5 * 1000);
    }

    if (!window.isLoaded) {
        window.addEventListener("load", function() {
            onDocumentReady();
        }, false);
    } else {
        onDocumentReady();
    }
    </script>
</body>

</html>